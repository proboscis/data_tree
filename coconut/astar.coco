import heapq
from loguru import logger
from lru import LRU
data Edge(src,dst,f,cost,name="unnamed")
class NoRouteException(Exception)
data Conversion(f,edges):
    def __call__(self,x):
        return self.f(x)
def new_conversion(edges):
    return Conversion(reduce((..>),[e.f for e in edges]),edges)
class _HeapContainer:
    def __init__(self,score,data):
        self.score = score
        self.data = data
    def __lt__(self,other):
        return self.score < other.score
def _astar(
          start,
          matcher,
          neighbors,
          heuristics,
          max_depth = 100):
    """
    neighbors: node->[(mapper,next_node,cost,name)]
    """
    to_visit = []
    scores = dict()
    scores[start] = heuristics(start)
    heapq.heappush(to_visit,
                   _HeapContainer(scores[start],(start,[])))

    while to_visit:
        hc = heapq.heappop(to_visit)
        score = hc.score
        (pos,trace) = hc.data
        #print(f"visit:{pos}")
        #print(f"{((trace[-1].a,trace[-1].name) if trace else 'no trace')}")
        #print(f"visit:{trace[-1] if trace else 'no trace'}")
        if len(trace) >= max_depth: # terminate search on max_depth
            continue
        if matcher(pos): # reached a goal
            return trace
        for mapper,next_node,cost,name in neighbors(pos):
            new_trace = trace + [Edge(pos,next_node,mapper,cost,name)]
            new_score = scores[pos] + cost + heuristics(next_node)
            if next_node in scores and scores[next_node] <= new_score:
                continue
            else:
                scores[next_node] = new_score
                heapq.heappush(to_visit,_HeapContainer(new_score,(next_node,new_trace)))

    raise NoRouteException(f"no route found from {start} matching {matcher}")

def _astar_direct(
          start,
          end,
          neighbors,
          heuristics,
          max_depth = 100):
    """
    neighbors: node->[(mapper,next_node,cost,name)]
    """
    to_visit = []
    scores = dict()
    scores[start] = heuristics(start)
    heapq.heappush(to_visit,
                   _HeapContainer(scores[start],(start,[])))

    while to_visit:
        hc = heapq.heappop(to_visit)
        score = hc.score
        (pos,trace) = hc.data
        #print(f"visit:{pos}")
        #print(f"{((trace[-1].a,trace[-1].name) if trace else 'no trace')}")
        #print(f"visit:{trace[-1] if trace else 'no trace'}")
        if len(trace) >= max_depth: # terminate search on max_depth
            continue
        if pos == end: # reached a goal
            return trace
        for mapper,next_node,cost,name in neighbors(pos):
            new_trace = trace + [Edge(pos,next_node,mapper,cost,name)]
            new_score = scores[pos] + cost + heuristics(next_node)
            if next_node in scores and scores[next_node] <= new_score:
                continue
            else:
                scores[next_node] = new_score
                heapq.heappush(to_visit,_HeapContainer(new_score,(next_node,new_trace)))

    raise NoRouteException(f"no route found from {start} matching {end}")

astar = _astar ..> new_conversion
astar_direct = _astar_direct ..> new_conversion
class AStarSolver:
    def __init__(self,rules=None,max_memo=1024):
        self.max_memo = max_memo
        self.rules = rules if rules is not None else []
        self.heuristics = x->0
        self.neighbors = (node->self._neighbors(node)) |> memoize(self.max_memo)
        self.search_memo = LRU(self.max_memo)
        self.direct_search_memo = LRU(self.max_memo)

    def _neighbors(self,node):
        res = []
        for rule in self.rules:
            edges = rule(node)
            if edges is not None:
                 res += edges
        return res

    def invalidate_cache(self):
        self.neighbors.cache_clear()
        self.search_memo.clear()
        self.direct_search_memo.clear()

    def add_rule(self,f):
        self.rules.append(f)
        self.invalidate_cache()

    def search(self,start,matcher):
        #problem is that you can't hash matcher
        #let's use id of matcher for now.
        q = (start,id(matcher))
        if q in self.search_memo:
            return self.search_memo[q]
        else:
            logger.debug(f"searching from {start} for matching {matcher}")
            res = astar(
                start=start,
                matcher=matcher,
                neighbors=self.neighbors,
                heuristics=self.heuristics
            )
            self.search_memo[q] = res
            return res

    def search_direct(self,start,end):
        q = (start,end)
        if q in self.direct_search_memo:
            return self.direct_search_memo[q]
        else:
            logger.debug(f"searching from {start} for {end}")
            res = astar_direct(
                start=start,
                end=end,
                neighbors=self.neighbors,
                heuristics=self.heuristics
            )
            self.direct_search_memo[q] = res
            return res