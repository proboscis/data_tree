from data_tree.coconut.astar import astar
from loguru import logger
import numpy as np
import torch
from PIL import Image
from data_tree import auto_image
from data_tree.coconut.convert import Torch,Numpy,VR_0_1,ImageDef
from data_tree.coconut.convert import str_to_img_def,_conversions,_edges
from data_tree.coconut.astar import AStarSolver
start = str_to_img_def("numpy,float32,HWC,RGB,0_1")
end = str_to_img_def("torch,uint8,BHWC,RGB,0_255")
data END from ImageDef
data DUMMY from ImageDef
def dummy_rule(imdef):
    return [(a->a,end,1,"dummy")]

def dummy_rule2(node):
    paths = []
    case node:
        match DUMMY():
            paths += [(a->END,END(),1,"to_end")]
        match _ is ImageDef:
            paths += [(a->DUMMY,DUMMY(),1,"to_dummy")]

    return paths

def test_something():
    def neighbors(node):
        return [(a->a+"a",node + "a",1,"add_a")]
    def matcher(node):
        return node == "aaa"
    def heuristics(node):
        return 0
    astar(
        start = "a",
        matcher=matcher,
        neighbors=neighbors,
        heuristics=heuristics
    ) |> log_conversion

def imdef_neighbors(imdef):
    return [(e.f,e.b,e.cost,e.name) for e in _edges(imdef)]

def test_new_astar():
    astar(
        start = start,
        matcher=d->d==end,
        neighbors = imdef_neighbors,
        heuristics=a->0
    )   |> log_conversion

def log_conversion(converter):
    path = [e.name for e in converter.edges]
    logger.info(path)



def test_astar_solver():


    solver=AStarSolver(
        rules = [imdef_neighbors]
    )
    solver.search_direct(start,end) |> log_conversion


    solver.add_rule(dummy_rule)
    solver.search_direct(start,end) |> log_conversion


def test_auto_image():
    x = np.zeros((100,100,3),dtype="float32")
    x = auto_image(x,start)
    x.converter(end) |> log_conversion
    x.solver.add_rule(dummy_rule)
    x.solver.add_rule(dummy_rule2)
    x.converter(end) |> log_conversion
    x.converter(END()) |> log_conversion
    x.reset_solver()

